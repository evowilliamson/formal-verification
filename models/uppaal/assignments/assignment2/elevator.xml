<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE nta PUBLIC '-//Uppaal Team//DTD Flat System 1.1//EN' 'http://www.it.uu.se/research/group/darts/uppaal/flat-1_2.dtd'>
<nta>
	<declaration>const int NO_FLOORS = 3;               // number of floors including the base floor
const int NO_ELEVATORS = 2;            // number of elevators
const int MAX_SIZE = 5;                // maximum amount of requests per elevator before it takes off
const int DOOR_TIME = 1;               // time it takes to close the door
const int FLOOR_TIME = 1;              // time to travel one floor
// IMPROVEMENT (stefano):
int MAX_WAIT = 5;                      // maximum amount of wait time before elevator runs with at least 1 person 
                                       // Don't set MAX_WAIT too high, as this increases the state-space

typedef int[0, NO_FLOORS - 1] id_f;    // floor id from 0 to NO_FLOORS - 1
typedef int[0, NO_ELEVATORS - 1] id_e; // elevator id from 0 to NO_ELEVATORS - 1

// time to open or close the door
 
// cabin door channels
chan open_door[id_e], close_door[id_e], door_open[id_e], door_closed[id_e]; 

// protecting door channels
chan open_pdoor[id_e], close_pdoor[id_e], pdoor_open[id_e], pdoor_closed[id_e];

// engine channels
chan stop[id_e], move_down[id_e], move_up[id_e];

// floor sensors channels and constants
chan start_sensors[id_e], stop_sensors[id_e], reach_floor[id_e];

// communications between button and request handlers
chan requests[id_f];

// communications between request handlers and main controller
chan go[id_e], served[id_e];

// The current floor of the elevator:
id_f current_floor[id_e]; 
// The floor to which the main control is requested to go to.
// This variable is just used for communication between the request handler and the main control.
// Therefore, we can declare it meta (i.e., not part of the state).
meta id_f target_floor[id_e];

// meta variable used to communicate selected floor between button and request handler
meta id_f requested_floor;
</declaration>
	<template>
		<name>engine</name>
		<parameter>id_e i</parameter>
		<location id="id0" x="16" y="-168">
			<committed/>
		</location>
		<location id="id1" x="-256" y="-168">
			<committed/>
		</location>
		<location id="id2" x="-112" y="-80">
			<committed/>
		</location>
		<location id="id3" x="-256" y="-48">
			<name x="-306" y="-34">moving_down</name>
		</location>
		<location id="id4" x="16" y="-48">
			<name x="-17" y="-34">moving_up</name>
		</location>
		<location id="id5" x="-112" y="-168">
			<name x="-127" y="-204">idle</name>
		</location>
		<init ref="id5"/>
		<transition>
			<source ref="id0"/>
			<target ref="id4"/>
			<label kind="synchronisation" x="24" y="-128">start_sensors[i]!</label>
		</transition>
		<transition>
			<source ref="id1"/>
			<target ref="id3"/>
			<label kind="synchronisation" x="-248" y="-128">start_sensors[i]!</label>
		</transition>
		<transition>
			<source ref="id2"/>
			<target ref="id5"/>
			<label kind="synchronisation" x="-104" y="-128">stop_sensors[i]!</label>
		</transition>
		<transition>
			<source ref="id3"/>
			<target ref="id2"/>
			<label kind="synchronisation" x="-204" y="-68">stop[i]?</label>
			<nail x="-216" y="-48"/>
			<nail x="-112" y="-48"/>
		</transition>
		<transition>
			<source ref="id5"/>
			<target ref="id1"/>
			<label kind="synchronisation" x="-224" y="-192">move_down[i]?</label>
		</transition>
		<transition>
			<source ref="id4"/>
			<target ref="id2"/>
			<label kind="synchronisation" x="-59" y="-68">stop[i]?</label>
			<nail x="-40" y="-48"/>
			<nail x="-112" y="-48"/>
		</transition>
		<transition>
			<source ref="id5"/>
			<target ref="id0"/>
			<label kind="synchronisation" x="-76" y="-195">move_up[i]?</label>
		</transition>
	</template>
	<template>
		<name>button</name>
		<declaration>clock x;</declaration>
		<location id="id6" x="-32" y="-8">
			<name x="-42" y="8">idle</name>
		</location>
		<init ref="id6"/>
		<transition>
			<source ref="id6"/>
			<target ref="id6"/>
			<label kind="select" x="-51" y="-119">f: id_f</label>
			<label kind="guard" x="-51" y="-102">x &gt;=1</label>
			<label kind="synchronisation" x="-51" y="-85">requests[f]!</label>
			<label kind="assignment" x="-51" y="-68">x = 0</label>
			<nail x="-64" y="-48"/>
			<nail x="0" y="-48"/>
		</transition>
	</template>
	<template>
		<name>dgc_request_handler</name>
		<parameter>id_e e</parameter>
		<declaration>clock x;
bool timer_started = false;

// Local queue storing the requests.
id_f list[MAX_SIZE + 1]; // Leave room for the base floor, the elevator has to go back after the trip
int[0, MAX_SIZE + 1] len = 0;

// local requested floor
int req_floor;
const int BASE_FLOOR = 0;

// Put an element at the end of the queue
void enqueue(id_f element)
{
        list[len++] = element;
}

// Remove the front element of the queue and return it to the caller
id_f dequeue()
{
        id_f element = list[0];
        int i = 0;
        len -= 1;
        while (i &lt; len)
        {
            list[i] = list[i + 1];
            i++;
        }
        list[i] = 0;
        return element;
 }

// Returns true if the queue has a size of 0
bool is_empty ()
{
	return len == 0;
}

// Returns true if the queue is full
bool is_full ()
{
	return len == MAX_SIZE;
}

// Returns true if either the queueu is full, or at least one request
// is present and atleast max_time has passed
bool is_ready_to_go()
{
 	return true; 
}

// Round function for two integers. According to the online-help functions should be
// available, but to no avail, couldn't be found. So create it here.
int round_int_division(int dividend, int divisor)
{
    return (dividend + (divisor / 2)) / divisor;
    // https://stackoverflow.com/questions/2422712/rounding-integer-division-instead-of-truncating
}

int group_size = round_int_division(NO_FLOORS, NO_ELEVATORS);

// Check whether the current elevator has affinity to process the floor 
bool is_req_for_elevator(id_f floor_no)
{
    return (floor_no / group_size) == e;

    /*
    11 floors, 3 elevators

    group_size = (11 + (3/2)) / 3 = 12 / 3 = 4

    floor      elevator
    -------------------
     0          0
     1          0
     2          0
     3          0
     4          1
     5          1
     6          1
     7          1
     8          2
     9          2
    10          2

    */
}

// Check whether the timer has been started
bool is_timer_started()
{
    return timer_started;
}

// Start the timer after the first request has been received
void start_timer() 
{
    x = 0;
    timer_started = true;
}

// Reset the timer. This means setting the timer_started boolean to false
void reset_timer() 
{
    timer_started = false;
}

// Function that sets the target floor, based on the dequeued requested floor
void set_target_floor(id_f floor_no)
{
    target_floor[e] = floor_no;
}

</declaration>
		<location id="id7" x="-1861" y="-1742">
			<name x="-1980" y="-1768">consider_timer</name>
			<committed/>
		</location>
		<location id="id8" x="-1615" y="-1742">
			<name x="-1598" y="-1725">checking_eligibility</name>
			<committed/>
		</location>
		<location id="id9" x="-1861" y="-1385">
			<name x="-1878" y="-1419">idle</name>
			<committed/>
		</location>
		<location id="id10" x="-1615" y="-1385">
			<name x="-1691" y="-1394">finished</name>
			<committed/>
		</location>
		<location id="id11" x="-1445" y="-1326">
			<name x="-1470" y="-1309">running</name>
		</location>
		<location id="id12" x="-1326" y="-1385">
			<name x="-1300" y="-1394">dequeued</name>
			<committed/>
		</location>
		<location id="id13" x="-1614" y="-1521">
			<name x="-1598" y="-1513">enqueueing</name>
		</location>
		<init ref="id9"/>
		<transition>
			<source ref="id7"/>
			<target ref="id7"/>
			<label kind="guard" x="-1946" y="-1666">!is_timer_started()</label>
			<label kind="assignment" x="-1946" y="-1649">start_timer()</label>
			<label kind="comments" x="-1946" y="-1632">IMPROVEMENT (stefano)
Start the counter after
the first request is
received. Then after 
MAX_WAIT time, start 
the cycle</label>
			<nail x="-1912" y="-1742"/>
			<nail x="-1912" y="-1674"/>
			<nail x="-1861" y="-1674"/>
		</transition>
		<transition>
			<source ref="id7"/>
			<target ref="id13"/>
			<label kind="guard" x="-1776" y="-1691">is_timer_started()</label>
		</transition>
		<transition>
			<source ref="id8"/>
			<target ref="id7"/>
			<label kind="guard" x="-1836" y="-1785">is_req_for_elevator(req_floor)</label>
			<label kind="assignment" x="-1793" y="-1768">enqueue(req_floor)</label>
		</transition>
		<transition>
			<source ref="id13"/>
			<target ref="id8"/>
			<label kind="select" x="-1606" y="-1674">sel_floor_no: id_f</label>
			<label kind="guard" x="-1606" y="-1657">!is_full() &amp;&amp; 
(is_empty() || x&lt;MAX_WAIT)</label>
			<label kind="synchronisation" x="-1606" y="-1623">requests[sel_floor_no]?</label>
			<label kind="assignment" x="-1606" y="-1606">req_floor = sel_floor_no</label>
		</transition>
		<transition>
			<source ref="id8"/>
			<target ref="id13"/>
			<label kind="guard" x="-1631" y="-1768">!is_req_for_elevator(req_floor)</label>
			<nail x="-1419" y="-1742"/>
			<nail x="-1419" y="-1547"/>
		</transition>
		<transition>
			<source ref="id9"/>
			<target ref="id13"/>
		</transition>
		<transition>
			<source ref="id10"/>
			<target ref="id13"/>
			<label kind="guard" x="-1606" y="-1470">is_empty()</label>
			<label kind="assignment" x="-1606" y="-1453">reset_timer()</label>
		</transition>
		<transition>
			<source ref="id10"/>
			<target ref="id12"/>
			<label kind="guard" x="-1564" y="-1428">!is_empty()</label>
			<label kind="assignment" x="-1564" y="-1411">set_target_floor(dequeue())</label>
		</transition>
		<transition>
			<source ref="id11"/>
			<target ref="id10"/>
			<label kind="synchronisation" x="-1598" y="-1343">served[e]?</label>
		</transition>
		<transition>
			<source ref="id12"/>
			<target ref="id11"/>
			<label kind="synchronisation" x="-1385" y="-1351">go[e]!</label>
		</transition>
		<transition>
			<source ref="id13"/>
			<target ref="id12"/>
			<label kind="guard" x="-1317" y="-1496">is_full() || 
(!is_empty() &amp;&amp; x&gt;=MAX_WAIT)</label>
			<label kind="assignment" x="-1317" y="-1462">enqueue(BASE_FLOOR), 
set_target_floor(dequeue())</label>
			<label kind="comments" x="-1394" y="-1887">NOTE: There are either two choices: 
1. When the queue is full or (the length of the queue is 
1 and more and MAX_WAIT time has passed): start the cycle 
2. In case the above is not true, keep on enqueueing. 

So, in this case, no invariant in the location is used. 
As a result, the x&gt;=MAX_WAIT can be safely negated, without 
taking into account the "="

Note that the sync input requests[e]? cannot create a 
deadlock: An extra location might be created, thus 
splitting the edge in two sequential edges. The first with 
the guard and the second edge with the requests[e]? sync. 
The location "enqueueing" could then by marked as 
"committed". It's clear that this doesn't create a deadlock. 
This was tested, but the extra edge and location didn't 
outweigh  the committed location. As a result, the state
space was being enlarged.</label>
			<nail x="-1326" y="-1521"/>
		</transition>
	</template>
	<template>
		<name>floor_sensors</name>
		<parameter>id_e i</parameter>
		<declaration>clock x;</declaration>
		<location id="id14" x="32" y="-24">
			<name x="-8" y="-8">moving</name>
			<label kind="invariant" x="40" y="-56">x &lt;= FLOOR_TIME</label>
		</location>
		<location id="id15" x="-200" y="-24">
			<name x="-264" y="-16">idle</name>
		</location>
		<init ref="id15"/>
		<transition>
			<source ref="id14"/>
			<target ref="id15"/>
			<label kind="synchronisation" x="-120" y="-112">stop_sensors[i]?</label>
			<nail x="32" y="-88"/>
			<nail x="-200" y="-88"/>
		</transition>
		<transition>
			<source ref="id14"/>
			<target ref="id14"/>
			<label kind="guard" x="136" y="-24">x &gt;= FLOOR_TIME</label>
			<label kind="synchronisation" x="136" y="-8">reach_floor[i]!</label>
			<label kind="assignment" x="136" y="8">x := 0</label>
			<nail x="128" y="-24"/>
			<nail x="128" y="32"/>
		</transition>
		<transition>
			<source ref="id15"/>
			<target ref="id14"/>
			<label kind="synchronisation" x="-128" y="-48">start_sensors[i]?</label>
			<label kind="assignment" x="-104" y="-16">x := 0</label>
		</transition>
	</template>
	<template>
		<name>cabin_door</name>
		<parameter>id_e i</parameter>
		<declaration>clock x;</declaration>
		<location id="id16" x="-348" y="42">
			<committed/>
		</location>
		<location id="id17" x="212" y="42">
			<committed/>
		</location>
		<location id="id18" x="212" y="-238">
			<committed/>
		</location>
		<location id="id19" x="-348" y="-238">
			<committed/>
		</location>
		<location id="id20" x="212" y="-85">
			<name x="228" y="-93">closed</name>
		</location>
		<location id="id21" x="-96" y="-88">
			<name x="-80" y="-88">executing</name>
			<label kind="invariant" x="-80" y="-104">x &lt;= DOOR_TIME</label>
		</location>
		<location id="id22" x="-348" y="-86">
			<name x="-425" y="-93">opened</name>
		</location>
		<init ref="id20"/>
		<transition>
			<source ref="id21"/>
			<target ref="id16"/>
			<label kind="synchronisation" x="-272" y="42">pdoor_open[i]?</label>
			<nail x="-102" y="42"/>
		</transition>
		<transition>
			<source ref="id17"/>
			<target ref="id21"/>
			<label kind="synchronisation" x="17" y="42">open_pdoor[i]!</label>
			<nail x="-93" y="42"/>
		</transition>
		<transition>
			<source ref="id21"/>
			<target ref="id18"/>
			<label kind="synchronisation" x="8" y="-263">pdoor_closed[i]?</label>
			<nail x="-93" y="-238"/>
		</transition>
		<transition>
			<source ref="id19"/>
			<target ref="id21"/>
			<label kind="synchronisation" x="-272" y="-263">close_pdoor[i]!</label>
			<nail x="-102" y="-238"/>
		</transition>
		<transition>
			<source ref="id16"/>
			<target ref="id22"/>
			<label kind="guard" x="-476" y="-50">x &gt;= DOOR_TIME</label>
			<label kind="synchronisation" x="-476" y="-34">door_open[i]!</label>
			<label kind="assignment" x="-476" y="-18">x := 0</label>
		</transition>
		<transition>
			<source ref="id20"/>
			<target ref="id17"/>
			<label kind="synchronisation" x="216" y="-40">open_door[i]?</label>
			<label kind="assignment" x="216" y="-16">x := 0</label>
		</transition>
		<transition>
			<source ref="id18"/>
			<target ref="id20"/>
			<label kind="guard" x="216" y="-184">x &gt;= DOOR_TIME</label>
			<label kind="synchronisation" x="216" y="-168">door_closed[i]!</label>
			<label kind="assignment" x="216" y="-152">x := 0</label>
		</transition>
		<transition>
			<source ref="id22"/>
			<target ref="id19"/>
			<label kind="synchronisation" x="-450" y="-185">close_door[i]?</label>
			<label kind="assignment" x="-450" y="-168">x := 0</label>
		</transition>
	</template>
	<template>
		<name>main_control</name>
		<parameter>id_e e</parameter>
		<declaration>// the current destination
id_f dest_floor = 1; 
//bool going_down = false;
//bool going_up = false;

// These two booleans are needed when handling the reached_floor sync action at the exact
// moment that the elevator has reached the destination floor. At that point the direction of
// movement is needed in order to calculate whether the destination has been reached or not.
// This could be done in the model itsef, but it would result in verbose code and would not
// make the model easier to read. Therefore, that logic will be put in dest_reached() function
int[-1, 1] direction = 0; // 0: no direction, 1: up, -1: down

// Convenience function to check what the direction of movement is. Check: going down ?
bool is_going_down ()
{
    if (direction == -1)
    {
        return true;
    }
    else
    {
        return false;
    }
}

// Convenience function to check what the direction of movement is. Check: going up ?
bool is_going_up ()
{
    if (direction == 1)
    {
        return true;
    }
    else
    {
        return false;
    }
}

// Convenience method to indicate that the elevator is going up
void going_up() 
{
    direction = 1;
}

// Convenience method to indicate that the elevator is going up
void going_down() 
{
    direction = -1;
}


void reset_direction()
{
   direction = 0;
}

// function that returns true if the destination floor is JUST ABOUT to be reached
bool is_dest_reached ()
{
    if ((is_going_up() &amp;&amp; (current_floor[e] + 1) == dest_floor) ||
        (is_going_down() &amp;&amp; (current_floor[e] - 1) == dest_floor))
    {
        return true;
    }
    else 
    {
        return false;
    }
}

// returns true if the elevator must go up
bool is_must_go_up ()
{
    if (current_floor[e] &lt; dest_floor) 
    {
        return true;
    }
    else 
    {
        return false;
    }
}

// convenience method that returns true if the elevator must go down
bool is_must_go_down ()
{
    return !is_must_go_up();
}

// This function adjusts the current_floor, depending of the movement of direction
void adjust_current_floor()
{
    if (is_must_go_up()) 
    {
        current_floor[e]++;
    }
    else 
    {
        current_floor[e]--;
    }
}

// Check whether the requested floor is to the same floor
bool is_req_to_same_floor() 
{
    return (dest_floor == current_floor[e]);
}

// Convenience method to move details to the declaraton section instead of the model
void set_dest_floor() 
{
    dest_floor = target_floor[e];
}
</declaration>
		<location id="id23" x="-2218" y="-2847">
			<name x="-2261" y="-2881">dest_reached</name>
			<committed/>
		</location>
		<location id="id24" x="-2898" y="-2703">
			<name x="-3017" y="-2711">handle_served</name>
			<committed/>
		</location>
		<location id="id25" x="-2898" y="-2771">
			<name x="-3008" y="-2779">door_opening</name>
		</location>
		<location id="id26" x="-2898" y="-2847">
			<name x="-2974" y="-2855">stopped</name>
			<committed/>
		</location>
		<location id="id27" x="-2583" y="-2626">
			<name x="-2626" y="-2660">door_closing</name>
		</location>
		<location id="id28" x="-2413" y="-2626">
			<name x="-2516" y="-2660">door__closed</name>
			<committed/>
		</location>
		<location id="id29" x="-2736" y="-2626">
			<committed/>
		</location>
		<location id="id30" x="-2218" y="-2626">
			<name x="-2201" y="-2652">moving</name>
		</location>
		<location id="id31" x="-2898" y="-2541">
			<name x="-2881" y="-2549">door_init_opening</name>
		</location>
		<location id="id32" x="-3026" y="-2541">
			<name x="-3043" y="-2524">idle</name>
			<committed/>
		</location>
		<location id="id33" x="-2898" y="-2626">
			<name x="-3017" y="-2635">door_opened</name>
		</location>
		<init ref="id32"/>
		<transition>
			<source ref="id29"/>
			<target ref="id24"/>
			<label kind="guard" x="-2728" y="-2686">is_req_to_same_floor()</label>
			<label kind="comments" x="-2728" y="-2779">IMPROVEMENT (ivo)
If the requested floor is 
equal to the current 
floor, shortcircuit the 
cycle and handle as served</label>
			<nail x="-2736" y="-2703"/>
		</transition>
		<transition>
			<source ref="id23"/>
			<target ref="id26"/>
			<label kind="synchronisation" x="-2592" y="-2873">stop[e]!</label>
		</transition>
		<transition>
			<source ref="id30"/>
			<target ref="id23"/>
			<label kind="guard" x="-2201" y="-2737">is_dest_reached()</label>
			<label kind="synchronisation" x="-2201" y="-2720">reach_floor[e]?</label>
			<label kind="assignment" x="-2202" y="-2703">adjust_current_floor()</label>
			<label kind="comments" x="-2201" y="-2830">IMPROVEMENT (stefano)
Refer to the declaration 
for the logic. Don't wait 
"floor_time" for the stop! 
sync action to be taken</label>
		</transition>
		<transition>
			<source ref="id27"/>
			<target ref="id28"/>
			<label kind="synchronisation" x="-2558" y="-2617">door_closed[e]?</label>
			<label kind="assignment" x="-2558" y="-2600">reset_direction()</label>
		</transition>
		<transition>
			<source ref="id24"/>
			<target ref="id33"/>
			<label kind="synchronisation" x="-2890" y="-2677">served[e]!</label>
		</transition>
		<transition>
			<source ref="id25"/>
			<target ref="id24"/>
			<label kind="synchronisation" x="-2889" y="-2754">door_open[e]?</label>
		</transition>
		<transition>
			<source ref="id26"/>
			<target ref="id25"/>
			<label kind="synchronisation" x="-2889" y="-2822">open_door[e]!</label>
		</transition>
		<transition>
			<source ref="id29"/>
			<target ref="id27"/>
			<label kind="guard" x="-2737" y="-2609">!is_req_to_same_floor()</label>
			<label kind="synchronisation" x="-2737" y="-2592">close_door[e]!</label>
		</transition>
		<transition>
			<source ref="id28"/>
			<target ref="id30"/>
			<label kind="guard" x="-2405" y="-2694">is_must_go_down()</label>
			<label kind="synchronisation" x="-2405" y="-2677">move_down[e]!</label>
			<label kind="assignment" x="-2405" y="-2660">going_down()</label>
			<nail x="-2414" y="-2703"/>
			<nail x="-2261" y="-2703"/>
		</transition>
		<transition>
			<source ref="id28"/>
			<target ref="id30"/>
			<label kind="guard" x="-2405" y="-2618">is_must_go_up()</label>
			<label kind="synchronisation" x="-2405" y="-2601">move_up[e]!</label>
			<label kind="assignment" x="-2404" y="-2584">going_up()</label>
			<nail x="-2414" y="-2558"/>
			<nail x="-2261" y="-2558"/>
		</transition>
		<transition>
			<source ref="id33"/>
			<target ref="id29"/>
			<label kind="synchronisation" x="-2864" y="-2618">go[e]?</label>
			<label kind="assignment" x="-2864" y="-2601">set_dest_floor()</label>
		</transition>
		<transition>
			<source ref="id30"/>
			<target ref="id30"/>
			<label kind="guard" x="-2218" y="-2565">!is_dest_reached()</label>
			<label kind="synchronisation" x="-2218" y="-2549">reach_floor[e]?</label>
			<label kind="assignment" x="-2218" y="-2532">adjust_current_floor()</label>
			<nail x="-2159" y="-2626"/>
			<nail x="-2159" y="-2575"/>
			<nail x="-2218" y="-2575"/>
		</transition>
		<transition>
			<source ref="id31"/>
			<target ref="id33"/>
			<label kind="synchronisation" x="-3009" y="-2592">door_open[e]?</label>
		</transition>
		<transition>
			<source ref="id32"/>
			<target ref="id31"/>
			<label kind="synchronisation" x="-3009" y="-2533">open_door[e]!</label>
		</transition>
	</template>
	<template>
		<name>protecting_door</name>
		<parameter>id_e i</parameter>
		<declaration>clock x;</declaration>
		<location id="id34" x="-112" y="8">
			<name x="-144" y="24">executing_open</name>
			<label kind="invariant" x="-144" y="40">x &lt;= DOOR_TIME</label>
		</location>
		<location id="id35" x="40" y="-96">
			<name x="59" y="-110">closed</name>
		</location>
		<location id="id36" x="-112" y="-120">
			<name x="-93" y="-127">executing</name>
			<label kind="invariant" x="-144" y="-104">x &lt;= DOOR_TIME</label>
		</location>
		<location id="id37" x="-232" y="-104">
			<name x="-289" y="-110">open</name>
		</location>
		<init ref="id35"/>
		<transition>
			<source ref="id34"/>
			<target ref="id37"/>
			<label kind="guard" x="-365" y="-75">x &gt;= DOOR_TIME</label>
			<label kind="synchronisation" x="-365" y="-59">pdoor_open[i]!</label>
			<label kind="assignment" x="-365" y="-43">x := 0</label>
			<nail x="-232" y="8"/>
			<nail x="-232" y="-80"/>
		</transition>
		<transition>
			<source ref="id35"/>
			<target ref="id34"/>
			<label kind="synchronisation" x="51" y="-68">open_pdoor[i]?</label>
			<label kind="assignment" x="51" y="-51">x := 0</label>
			<nail x="40" y="-32"/>
			<nail x="40" y="8"/>
		</transition>
		<transition>
			<source ref="id36"/>
			<target ref="id35"/>
			<label kind="guard" x="-85" y="-211">x &gt;= DOOR_TIME</label>
			<label kind="synchronisation" x="-85" y="-195">pdoor_closed[i]!</label>
			<label kind="assignment" x="-85" y="-179">x := 0</label>
			<nail x="-96" y="-152"/>
			<nail x="40" y="-152"/>
		</transition>
		<transition>
			<source ref="id37"/>
			<target ref="id36"/>
			<label kind="synchronisation" x="-229" y="-195">close_pdoor[i]?</label>
			<label kind="assignment" x="-229" y="-178">x := 0</label>
			<nail x="-232" y="-152"/>
			<nail x="-128" y="-152"/>
		</transition>
	</template>
	<system>system cabin_door, protecting_door, engine, floor_sensors, button, dgc_request_handler, main_control;</system>
	<queries>
		<query>
			<formula>A[] (engine(0).moving_up or engine(0).moving_down) imply (cabin_door(0).closed and protecting_door(0).closed)
			</formula>
			<comment>
			</comment>
		</query>
		<query>
			<formula>E&lt;&gt; dgc_request_handler(0).enqueueing and dgc_request_handler(0).is_full() and current_floor[0] == 0
			</formula>
			<comment>The formulation of the property is not succint enough. I interpret: "The amount of perceivable requests for one specifc elevator can reach the threshold value". 
"perceivable" because in essence a button generates the requests and the model could (if enough information available) detect that the number of requests reaches a certain amount already in the button.
 But because of the fact that the data structures that accumulates the requests is contained in the request_handler, I guess it is assumed that this is not the case.
"specific": I guess the property holds for just one elevator, and not the total amount of requests in the system (for all elevators). Again for the same reason as previously stated

			</comment>
		</query>
		<query>
			<formula>A[] not deadlock
			</formula>
			<comment>
			</comment>
		</query>
	</queries>
</nta>
